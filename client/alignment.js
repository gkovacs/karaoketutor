// Generated by LiveScript 1.2.0
var root, prelude, FRACSEC, logsToTimeListHold, logsToTimeList, main;
root = typeof global != 'undefined' && global !== null ? global : window;
if (typeof prelude == 'undefined' || prelude === null) {
  if (root.prelude != null) {
    prelude = root.prelude;
  } else {
    prelude = require('prelude-ls');
  }
}
FRACSEC = 4;
logsToTimeListHold = root.logsToTimeListHold = function(logs){
  var maxVideoTime, videoTime, maxTime, maxIdx, wordIdx, output, i$, ref$, len$, time, sortedLogs, idx, ref1$, startTime, nextVideoTime, nextTime, j$, len1$;
  maxVideoTime = prelude.maximum((function(){
    var i$, ref$, len$, results$ = [];
    for (i$ = 0, len$ = (ref$ = logs).length; i$ < len$; ++i$) {
      videoTime = ref$[i$].videoTime;
      results$.push(videoTime);
    }
    return results$;
  }()));
  maxTime = Math.round(maxVideoTime * FRACSEC);
  maxIdx = prelude.maximum((function(){
    var i$, ref$, len$, results$ = [];
    for (i$ = 0, len$ = (ref$ = logs).length; i$ < len$; ++i$) {
      wordIdx = ref$[i$].wordIdx;
      results$.push(wordIdx);
    }
    return results$;
  }()));
  output = [];
  for (i$ = 0, len$ = (ref$ = (fn$())).length; i$ < len$; ++i$) {
    time = ref$[i$];
    output.push(repeatArray$([0], maxIdx + 1));
  }
  sortedLogs = prelude.sortBy(function(it){
    return it.videoTime;
  }, logs);
  for (i$ = 0, len$ = (ref$ = (fn1$())).length; i$ < len$; ++i$) {
    idx = ref$[i$];
    ref1$ = sortedLogs[idx], wordIdx = ref1$.wordIdx, videoTime = ref1$.videoTime;
    startTime = Math.round(videoTime * FRACSEC);
    nextVideoTime = sortedLogs[idx + 1];
    if (nextVideoTime == null) {
      nextVideoTime = maxVideoTime;
    }
    nextTime = Math.round(nextVideoTime * FRACSEC);
    for (j$ = 0, len1$ = (ref1$ = (fn2$())).length; j$ < len1$; ++j$) {
      time = ref1$[j$];
      output[time][wordIdx] += 1;
    }
  }
  return output;
  function fn$(){
    var i$, to$, results$ = [];
    for (i$ = 0, to$ = maxTime; i$ <= to$; ++i$) {
      results$.push(i$);
    }
    return results$;
  }
  function fn1$(){
    var i$, to$, results$ = [];
    for (i$ = 0, to$ = sortedLogs.length; i$ < to$; ++i$) {
      results$.push(i$);
    }
    return results$;
  }
  function fn2$(){
    var i$, to$, results$ = [];
    for (i$ = startTime, to$ = nextTime; i$ < to$; ++i$) {
      results$.push(i$);
    }
    return results$;
  }
};
logsToTimeList = root.logsToTimeList = function(logs){
  var maxTime, videoTime, maxIdx, wordIdx, output, i$, ref$, len$, time;
  maxTime = prelude.maximum((function(){
    var i$, ref$, len$, results$ = [];
    for (i$ = 0, len$ = (ref$ = logs).length; i$ < len$; ++i$) {
      videoTime = ref$[i$].videoTime;
      results$.push(Math.round(videoTime * FRACSEC));
    }
    return results$;
  }()));
  maxIdx = prelude.maximum((function(){
    var i$, ref$, len$, results$ = [];
    for (i$ = 0, len$ = (ref$ = logs).length; i$ < len$; ++i$) {
      wordIdx = ref$[i$].wordIdx;
      results$.push(wordIdx);
    }
    return results$;
  }()));
  output = [];
  for (i$ = 0, len$ = (ref$ = (fn$())).length; i$ < len$; ++i$) {
    time = ref$[i$];
    output.push(repeatArray$([0], maxIdx + 1));
  }
  for (i$ = 0, len$ = logs.length; i$ < len$; ++i$) {
    ref$ = logs[i$], wordIdx = ref$.wordIdx, videoTime = ref$.videoTime;
    time = Math.round(videoTime * FRACSEC);
    output[time][wordIdx] += 1;
  }
  return output;
  function fn$(){
    var i$, to$, results$ = [];
    for (i$ = 0, to$ = maxTime; i$ <= to$; ++i$) {
      results$.push(i$);
    }
    return results$;
  }
};
main = function(){
  var logs, timeList, compute_time_word_path, time_word_path;
  logs = JSON.parse(require('fs').readFileSync('darkhorselog.json', 'utf-8'));
  timeList = logsToTimeList(logs);
  compute_time_word_path = require('./alignment_core').compute_time_word_path;
  time_word_path = compute_time_word_path(timeList);
  return console.log(JSON.stringify(time_word_path));
};
if ((typeof module != 'undefined' && module !== null) && require.main === module) {
  main();
}
function repeatArray$(arr, n){
  for (var r = []; n > 0; (n >>= 1) && (arr = arr.concat(arr)))
    if (n & 1) r.push.apply(r, arr);
  return r;
}