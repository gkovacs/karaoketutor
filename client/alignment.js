// Generated by LiveScript 1.2.0
var root, prelude, FRACSEC, logsToTimeListHoldMulti, logsToTimeListHold, logsToTimeList, compute_time_word_path, main;
root = typeof global != 'undefined' && global !== null ? global : window;
if (typeof prelude == 'undefined' || prelude === null) {
  if (root.prelude != null) {
    prelude = root.prelude;
  } else {
    prelude = require('prelude-ls');
  }
}
FRACSEC = 4;
logsToTimeListHoldMulti = root.logsToTimeListHoldMulti = function(logsList){
  var maxVideoTime, logs, videoTime, maxTime, maxIdx, wordIdx, output, i$, ref$, len$, time, sortedLogs, j$, len1$, idx, ref1$, startTime, nextIntervalData, nextTime, k$, len2$;
  maxVideoTime = prelude.maximum((function(){
    var i$, ref$, len$, results$ = [];
    for (i$ = 0, len$ = (ref$ = logsList).length; i$ < len$; ++i$) {
      logs = ref$[i$];
      results$.push(prelude.maximum((fn$())));
    }
    return results$;
    function fn$(){
      var i$, ref$, len$, results$ = [];
      for (i$ = 0, len$ = (ref$ = logs).length; i$ < len$; ++i$) {
        videoTime = ref$[i$].videoTime;
        results$.push(videoTime);
      }
      return results$;
    }
  }()));
  maxTime = Math.round(maxVideoTime * FRACSEC);
  maxIdx = prelude.maximum((function(){
    var i$, ref$, len$, results$ = [];
    for (i$ = 0, len$ = (ref$ = logsList).length; i$ < len$; ++i$) {
      logs = ref$[i$];
      results$.push(prelude.maximum((fn$())));
    }
    return results$;
    function fn$(){
      var i$, ref$, len$, results$ = [];
      for (i$ = 0, len$ = (ref$ = logs).length; i$ < len$; ++i$) {
        wordIdx = ref$[i$].wordIdx;
        results$.push(wordIdx);
      }
      return results$;
    }
  }()));
  output = [];
  for (i$ = 0, len$ = (ref$ = (fn$())).length; i$ < len$; ++i$) {
    time = ref$[i$];
    output.push(repeatArray$([0], maxIdx + 1));
  }
  for (i$ = 0, len$ = logsList.length; i$ < len$; ++i$) {
    logs = logsList[i$];
    sortedLogs = prelude.sortBy(fn1$, logs);
    for (j$ = 0, len1$ = (ref$ = (fn2$())).length; j$ < len1$; ++j$) {
      idx = ref$[j$];
      ref1$ = sortedLogs[idx], wordIdx = ref1$.wordIdx, videoTime = ref1$.videoTime;
      startTime = Math.round(videoTime * FRACSEC);
      nextIntervalData = sortedLogs[idx + 1];
      if (nextIntervalData != null) {
        nextTime = Math.round(
        nextIntervalData.videoTime * FRACSEC);
      } else {
        nextTime = maxTime + 1;
      }
      for (k$ = 0, len2$ = (ref1$ = (fn3$())).length; k$ < len2$; ++k$) {
        time = ref1$[k$];
        output[time][wordIdx] += 1;
      }
    }
  }
  return output;
  function fn$(){
    var i$, to$, results$ = [];
    for (i$ = 0, to$ = maxTime; i$ <= to$; ++i$) {
      results$.push(i$);
    }
    return results$;
  }
  function fn1$(it){
    return it.videoTime;
  }
  function fn2$(){
    var i$, to$, results$ = [];
    for (i$ = 0, to$ = sortedLogs.length; i$ < to$; ++i$) {
      results$.push(i$);
    }
    return results$;
  }
  function fn3$(){
    var i$, to$, results$ = [];
    for (i$ = startTime, to$ = nextTime; i$ < to$; ++i$) {
      results$.push(i$);
    }
    return results$;
  }
};
logsToTimeListHold = root.logsToTimeListHold = function(logs){
  var maxVideoTime, videoTime, maxTime, maxIdx, wordIdx, output, i$, ref$, len$, time, sortedLogs, idx, ref1$, startTime, nextIntervalData, nextTime, j$, len1$;
  maxVideoTime = prelude.maximum((function(){
    var i$, ref$, len$, results$ = [];
    for (i$ = 0, len$ = (ref$ = logs).length; i$ < len$; ++i$) {
      videoTime = ref$[i$].videoTime;
      results$.push(videoTime);
    }
    return results$;
  }()));
  maxTime = Math.round(maxVideoTime * FRACSEC);
  maxIdx = prelude.maximum((function(){
    var i$, ref$, len$, results$ = [];
    for (i$ = 0, len$ = (ref$ = logs).length; i$ < len$; ++i$) {
      wordIdx = ref$[i$].wordIdx;
      results$.push(wordIdx);
    }
    return results$;
  }()));
  output = [];
  for (i$ = 0, len$ = (ref$ = (fn$())).length; i$ < len$; ++i$) {
    time = ref$[i$];
    output.push(repeatArray$([0], maxIdx + 1));
  }
  sortedLogs = prelude.sortBy(function(it){
    return it.videoTime;
  }, logs);
  for (i$ = 0, len$ = (ref$ = (fn1$())).length; i$ < len$; ++i$) {
    idx = ref$[i$];
    ref1$ = sortedLogs[idx], wordIdx = ref1$.wordIdx, videoTime = ref1$.videoTime;
    startTime = Math.round(videoTime * FRACSEC);
    nextIntervalData = sortedLogs[idx + 1];
    if (nextIntervalData != null) {
      nextTime = Math.round(
      nextIntervalData.videoTime * FRACSEC);
    } else {
      nextTime = maxTime + 1;
    }
    for (j$ = 0, len1$ = (ref1$ = (fn2$())).length; j$ < len1$; ++j$) {
      time = ref1$[j$];
      output[time][wordIdx] += 1;
    }
  }
  return output;
  function fn$(){
    var i$, to$, results$ = [];
    for (i$ = 0, to$ = maxTime; i$ <= to$; ++i$) {
      results$.push(i$);
    }
    return results$;
  }
  function fn1$(){
    var i$, to$, results$ = [];
    for (i$ = 0, to$ = sortedLogs.length; i$ < to$; ++i$) {
      results$.push(i$);
    }
    return results$;
  }
  function fn2$(){
    var i$, to$, results$ = [];
    for (i$ = startTime, to$ = nextTime; i$ < to$; ++i$) {
      results$.push(i$);
    }
    return results$;
  }
};
logsToTimeList = root.logsToTimeList = function(logs){
  var maxTime, videoTime, maxIdx, wordIdx, output, i$, ref$, len$, time;
  maxTime = prelude.maximum((function(){
    var i$, ref$, len$, results$ = [];
    for (i$ = 0, len$ = (ref$ = logs).length; i$ < len$; ++i$) {
      videoTime = ref$[i$].videoTime;
      results$.push(Math.round(videoTime * FRACSEC));
    }
    return results$;
  }()));
  maxIdx = prelude.maximum((function(){
    var i$, ref$, len$, results$ = [];
    for (i$ = 0, len$ = (ref$ = logs).length; i$ < len$; ++i$) {
      wordIdx = ref$[i$].wordIdx;
      results$.push(wordIdx);
    }
    return results$;
  }()));
  output = [];
  for (i$ = 0, len$ = (ref$ = (fn$())).length; i$ < len$; ++i$) {
    time = ref$[i$];
    output.push(repeatArray$([0], maxIdx + 1));
  }
  for (i$ = 0, len$ = logs.length; i$ < len$; ++i$) {
    ref$ = logs[i$], wordIdx = ref$.wordIdx, videoTime = ref$.videoTime;
    time = Math.round(videoTime * FRACSEC);
    output[time][wordIdx] += 1;
  }
  return output;
  function fn$(){
    var i$, to$, results$ = [];
    for (i$ = 0, to$ = maxTime; i$ <= to$; ++i$) {
      results$.push(i$);
    }
    return results$;
  }
};
compute_time_word_path = root.compute_time_word_path = function(time_to_gwordnum_count){
  var DP, backptr_wordtrans, time, gwordnum_count, i$, ref$, len$, gwordnum, j$, len1$, wordtransition_score, wordstay_score, time_to_word, last_row, word_idx, i, is_wordtrans;
  DP = [];
  backptr_wordtrans = [];
  for (time in time_to_gwordnum_count) {
    gwordnum_count = time_to_gwordnum_count[time];
    DP[time] = [];
    backptr_wordtrans[time] = [];
    for (i$ = 0, len$ = (ref$ = (fn$())).length; i$ < len$; ++i$) {
      gwordnum = ref$[i$];
      DP[time].push(0);
      backptr_wordtrans[time].push(0);
    }
  }
  for (i$ = 0, len$ = time_to_gwordnum_count.length; i$ < len$; ++i$) {
    time = i$;
    gwordnum_count = time_to_gwordnum_count[i$];
    if (time === 0) {
      DP[0][0] = time_to_gwordnum_count[0][0];
      continue;
    }
    for (j$ = 0, len1$ = (ref$ = (fn1$())).length; j$ < len1$; ++j$) {
      gwordnum = ref$[j$];
      wordtransition_score = -1;
      if (gwordnum > 0) {
        wordtransition_score = DP[time - 1][gwordnum - 1] + time_to_gwordnum_count[time][gwordnum];
      }
      wordstay_score = -1;
      if (DP[time - 1] != null && DP[time - 1][gwordnum] != null) {
        wordstay_score = DP[time - 1][gwordnum] + time_to_gwordnum_count[time][gwordnum];
      }
      if (wordtransition_score > wordstay_score) {
        backptr_wordtrans[time][gwordnum] = 1;
        DP[time][gwordnum] = wordtransition_score;
      } else {
        DP[time][gwordnum] = wordstay_score;
      }
    }
  }
  time_to_word = [];
  last_row = backptr_wordtrans[backptr_wordtrans.length - 1];
  word_idx = last_row.length - 1;
  for (i$ = 0, len$ = (ref$ = (fn2$())).length; i$ < len$; ++i$) {
    i = ref$[i$];
    is_wordtrans = backptr_wordtrans[i][word_idx];
    time_to_word.push(word_idx);
    if (is_wordtrans) {
      word_idx -= 1;
    }
  }
  time_to_word.reverse();
  return time_to_word;
  function fn$(){
    var i$, to$, results$ = [];
    for (i$ = 0, to$ = Math.min(time, gwordnum_count.length - 1); i$ <= to$; ++i$) {
      results$.push(i$);
    }
    return results$;
  }
  function fn1$(){
    var i$, to$, results$ = [];
    for (i$ = 0, to$ = Math.min(time, gwordnum_count.length - 1); i$ <= to$; ++i$) {
      results$.push(i$);
    }
    return results$;
  }
  function fn2$(){
    var i$, results$ = [];
    for (i$ = backptr_wordtrans.length - 1; i$ >= 0; --i$) {
      results$.push(i$);
    }
    return results$;
  }
};
main = function(){
  var logs, timeList, time_word_path;
  logs = JSON.parse(require('fs').readFileSync('darkhorselog.json', 'utf-8'));
  timeList = logsToTimeList(logs);
  time_word_path = compute_time_word_path(timeList);
  return console.log(JSON.stringify(time_word_path));
};
if ((typeof module != 'undefined' && module !== null) && require.main === module) {
  main();
}
function repeatArray$(arr, n){
  for (var r = []; n > 0; (n >>= 1) && (arr = arr.concat(arr)))
    if (n & 1) r.push.apply(r, arr);
  return r;
}